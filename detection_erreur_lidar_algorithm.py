# -*- coding: utf-8 -*-

"""
/***************************************************************************
 DetectionErreursLidar
                                 A QGIS plugin
 Ce plugin détecte les points de classe sol déclassés par erreur.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-03-15
        copyright            : (C) 2023 by Lubin, Ibtissam, Judith, Estelle
        email                : estellounette@ensg.eu
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Lubin, Ibtissam, Judith, Estelle'
__date__ = '2023-03-15'
__copyright__ = '(C) 2023 by Lubin, Ibtissam, Judith, Estelle'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import (QgsProcessing,
                       QgsFeatureSink,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterFeatureSink)

from qgis.core import QgsProcessingUtils
from qgis.core import QgsProcessingMultiStepFeedback
from qgis.core import QgsProcessingParameterFolderDestination
from qgis.core import QgsProcessingParameterVectorLayer
from qgis.core import QgsProcessingParameterVectorDestination,QgsVectorLayer
from qgis.core import QgsProcessingParameterFile, QgsProcessingParameterNumber,QgsProcessingParameterFileDestination
import processing
                    
import pandas as pd
import numpy as np
import laspy
import os

from osgeo import ogr
from osgeo import gdal
from osgeo import osr
import numpy as np


class DetectionErreursLidarAlgorithm(QgsProcessingAlgorithm):
    """
    This is an example algorithm that takes a vector layer and
    creates a new identical one.

    It is meant to be used as an example of how to create your own
    algorithms and explain methods and variables used to do it. An
    algorithm like this will be available in all elements, and there
    is not need for additional work.

    All Processing algorithms should extend the QgsProcessingAlgorithm
    class.
    """

    def initAlgorithm(self, config=None):
        #Données d'entrée du modèle
#        self.addParameter(QgsProcessingParameterFile('nuage', 'nuage', defaultValue=None))
        self.addParameter(QgsProcessingParameterFile('nuage', 'Données en entrée :\n\nNuage de points à corriger (.las)', defaultValue=None))
        self.addParameter(QgsProcessingParameterVectorLayer('verite_terrain', 'Vérité terrain ponctuelle (si disponible)', types=[QgsProcessing.TypeVectorPoint], optional = True, defaultValue=None))
        self.addParameter(QgsProcessingParameterNumber('pixel_size','Taille du pixel pour la rasterisation',type = QgsProcessingParameterNumber.Double,defaultValue=2))
        self.addParameter(QgsProcessingParameterNumber('surface1','Premier seuil de surface (m²)',type = QgsProcessingParameterNumber.Double,defaultValue=100))
        self.addParameter(QgsProcessingParameterNumber('ouverture',"Distance d'ouverture (m)",type = QgsProcessingParameterNumber.Double,defaultValue=2))
        self.addParameter(QgsProcessingParameterNumber('surface2','Second seuil de surface (m²)',type = QgsProcessingParameterNumber.Double,defaultValue=100))
        self.addParameter(QgsProcessingParameterNumber('fermeture',"Distance de fermeture (m)",type = QgsProcessingParameterNumber.Double,defaultValue=2))
        self.addParameter(QgsProcessingParameterNumber('convexite','Seuil minimal de convexité',type = QgsProcessingParameterNumber.Double,defaultValue=0.55))
        self.addParameter(QgsProcessingParameterNumber('elongation',"Seuil minimal d'élongation",type = QgsProcessingParameterNumber.Double,defaultValue=2))
        
        #Dossier de stockage des données générées
        #self.addParameter(QgsProcessingParameterFolderDestination('folder','folder', defaultValue=None))
        
        #Fichier à exporter
        self.addParameter(QgsProcessingParameterVectorDestination('Verite_dalle', "\n\n\nDonnées en sortie :\n\nVérité terrain tronquée à l'emprise de la dalle à exporter (optionnel)", type=QgsProcessing.TypeVectorAnyGeometry, createByDefault=True, defaultValue=None))
        self.addParameter(QgsProcessingParameterFileDestination('nuage_sol_bati', 'Nuage de points sol et bâti à exporté (optionnel)',createByDefault=True, defaultValue=None))
        self.addParameter(QgsProcessingParameterFileDestination('raster', 'Raster de sol et bâti à exporter (optionnel)', createByDefault=True, defaultValue=None))
        self.addParameter(QgsProcessingParameterFeatureSink('Polygones', 'Polygones de trous à exporter (optionnel)', type=QgsProcessing.TypeVectorAnyGeometry, createByDefault=True, supportsAppend=True, defaultValue=None))
        self.addParameter(QgsProcessingParameterFeatureSink('Ouverture', "Résultats de l'ouverture à exporter (optionnel)", type=QgsProcessing.TypeVectorAnyGeometry, createByDefault=True, supportsAppend=True, defaultValue=None))
        self.addParameter(QgsProcessingParameterFeatureSink('Fermeture', 'Résultats de la fermeture à exporter (optionnel)', type=QgsProcessing.TypeVectorPolygon, createByDefault=True, supportsAppend=True, defaultValue=None))
        self.addParameter(QgsProcessingParameterFeatureSink('Ombb', 'Plus petits rectangles englobants à exporter (optionnel)', type=QgsProcessing.TypeVectorAnyGeometry, createByDefault=True, supportsAppend=True, defaultValue=None))
        self.addParameter(QgsProcessingParameterFeatureSink('Resultat', 'Résultats de la procédure à exporter', type=QgsProcessing.TypeVectorAnyGeometry, createByDefault=True, defaultValue=None))
        self.addParameter(QgsProcessingParameterFeatureSink('Bien_detectee', 'Résultats bien détectés à exporter (si vérité terrain fournie)(optionnel)', type=QgsProcessing.TypeVectorAnyGeometry, createByDefault=True, defaultValue=None))
        
####################################################### CREE UN FICHIER DES POINTS SOL ET BATI À PARTIR DU NUAGE DE POINTS

    def processAlgorithm(self, parameters, context, model_feedback):
        feedback = QgsProcessingMultiStepFeedback(21, model_feedback)
        results = {} #Dictionnaire où seront placés les résultats à exporter
        outputs = {} #Dictionnaire où seront placés toutes les sorties de tous les algorithmes
        
        #Récupère le dossier de stockage des fichiers temporaires
        temp_folder = QgsProcessingUtils.tempFolder()
        temp_folder = temp_folder.replace('/','\\')

        if  'TEMPORARY_OUTPUT' in str(parameters['nuage_sol_bati']) :
            nsb_path = temp_folder + '\\nsb.las'
        else:
            nsb_path = parameters['nuage_sol_bati']
            
        # Crée le dossier de sortie passé en paramètre si inexistant
        dirName = os.path.dirname(nsb_path)
        if not os.path.exists(dirName):
            os.mkdir(dirName)
        
        #Récupère le nom du dossier où est localisé le nuage de points
        file = parameters['nuage']
        file_name = os.path.basename(file)
        file_name = os.path.splitext(file_name)[0]
        
        #Ouvre le nuage de points et récupère les points de classe n°2 càd les points classés comme sol
        with laspy.open(r'{}'.format(file)) as fh:
            las = fh.read()
            ground_pts = las.classification == 2
            bins, counts = np.unique(las.return_number[ground_pts], return_counts=True)
    
        #Lit le nuage de points et le rend modifiable
        las = laspy.read(r'{}'.format(file))
        
        #Exporte un nouveau fichier .las dans un nouveau répertoire les points du sol
        if  'TEMPORARY_OUTPUT' in str(parameters['nuage_sol_bati']) :
            chemin = f'{dirName}\extracted_sol_bati_{file_name}.las'
        else:
            chemin = parameters['nuage_sol_bati']
        #chemin = f'{dirName}\extracted_sol_bati_{file_name}.las'
        new_file = laspy.create(point_format=las.header.point_format, file_version=las.header.version)
        new_file.points = las.points[las.classification == 2]
        new_file.write(r'{}'.format(chemin))
        
        #Ajoute au fichier des points du sol les points de classe 6 càd les points classés comme bâtiments
        with laspy.open(r'{}'.format(chemin), mode='a') as fh:
            fh.append_points(las.points[las.classification == 6])
        
####################################################### EXPORTE VERS UN FICHIER RASTER LE NUAGE DE POINTS SOL/BATI

        srs = '[EPSG:2154]' #Chaîne de caractères du système de référence
        las = laspy.read(chemin) # Un fichier laspy
        
        if  'TEMPORARY_OUTPUT' in str(parameters['raster']) :
            tif = temp_folder + '\\raster.tif'
        else:
            tif = parameters['raster']
        tif.replace('\\','/')
        #tif = dirName + '/raster.tif' #Crée le chemin d'accès au tif
    
        driver = ogr.GetDriverByName('Memory')
    
        # Crée la source de données
        data_source = driver.CreateDataSource('in_mem')
    
        # Crée la référence spatiale à partir du système de référence srs
        sr = osr.SpatialReference()
        sr.ImportFromWkt(srs)
    
        #Crée une couche 'points' de points qui récupère la référence spatiale sr
        layer = data_source.CreateLayer('points', sr, ogr.wkbPoint)
    
        # Place dans une matrice les listes de coordonnées en X, Y et Z des points du nuage de points
        las_points = np.vstack((las.x, las.y, las.z)).transpose()
    
        for pnt in las_points:
            #Crée une entité dans la couche 'points' pour chaque point
            feature = ogr.Feature(layer.GetLayerDefn())
            #Récupère en format WKT les coordonnées de l'entité
            wkt = 'POINT ({0} {1} {2})'.format(float(pnt[0]), float(pnt[1]), float(pnt[2]))
            #Crée le point correspondant à l'entité à partir de ses coordonnées WKT
            point = ogr.CreateGeometryFromWkt(wkt)
            #Définit la géométrie de l'entité comme étant un point
            feature.SetGeometry(point)
            #Crée l'entité dans la couche
            layer.CreateFeature(feature)
            # dereference the feature
            feature = None
        
        #Calcule la résolution du raster à créer à partir de la taille du pixel saisie en entrée
        pixel_size = parameters['pixel_size']
        xmin, xmax, ymin, ymax = layer.GetExtent()
        x_res = int((xmax - xmin) / pixel_size) + 1  # round up and add additional pixel for remainder
        y_res = int((ymax - ymin) / pixel_size) + 1  # round up and add additional pixel for remainder
    
        #Crée le raster binaire GTiff 'target_ds' selon les caractéristiques calculées au-dessus dans le chemin d'accès 'tif'
        target_ds = gdal.GetDriverByName('GTiff').Create(tif, x_res, y_res, 1, gdal.GDT_Byte)
        target_ds.SetGeoTransform((xmin, pixel_size, 0, ymax, 0, -pixel_size))
        band = target_ds.GetRasterBand(1)
        band.SetNoDataValue(0)
    
        # Rasterise la couche 'layer' selon le raster 'target_ds'
        gdal.RasterizeLayer(target_ds, [1], layer, options=["BURN_VALUE_FROM=Z"])
        layer = None
        target_ds.FlushCache()
        del target_ds
            
####################################################### TRAITEMENTS DE LA COUCHE RASTER POUR OBTENIR LES EVENTUELS POLYGONES D'ERREURS
        
        
        # Remplir les cellules sans données du raster par des 0
        alg_params = {
            'BAND': 1,
            'FILL_VALUE': 0,
            'INPUT': tif,
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['RemplirLesCellulesSansDonnes'] = processing.run('native:fillnodata', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(1)
        if feedback.isCanceled():
            return {}

        # Transforme chaque pixel du raster en un polygone
        alg_params = {
            'FIELD_NAME': 'VALUE',
            'INPUT_RASTER': outputs['RemplirLesCellulesSansDonnes']['OUTPUT'],
            'RASTER_BAND': 1,
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['PixelsDeRasterEnPolygones'] = processing.run('native:pixelstopolygons', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(2)
        if feedback.isCanceled():
            return {}

        # Extraire l'emprise de la couche 'tif'
        alg_params = {
            'INPUT': tif,
            'ROUND_TO': 0,
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['ExtraireLempriseDeLaCouche'] = processing.run('native:polygonfromlayerextent', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(3)
        if feedback.isCanceled():
            return {}

        # Découper la couche de vérité terrain selon l'emprise de la couche 'tif'
        if 'None' not in str(parameters['verite_terrain']) :
            if  'TEMPORARY_OUTPUT' in str(parameters['Verite_dalle']) :
                vd_path = temp_folder + '\\verite_dalle.shp'
            else:
                vd_path = parameters['Verite_dalle']
    
            alg_params = {
                'EXTENT': outputs['ExtraireLempriseDeLaCouche']['OUTPUT'],
                'INPUT': parameters['verite_terrain'],
                'OPTIONS': '',
                'OUTPUT': vd_path
            }
            outputs['DcouperDesVecteursSelonUneEmprise'] = processing.run('gdal:clipvectorbyextent', alg_params, context=context, feedback=feedback, is_child_algorithm=True)
            results['Verite_dalle'] = outputs['DcouperDesVecteursSelonUneEmprise']['OUTPUT']

            feedback.setCurrentStep(4)
            if feedback.isCanceled():
                return {}

        # Extrait les polygones dont l'attribut de valeur vaut '0' càd les pixels ne correspondant ni à des points sol ni à des points bâti
        alg_params = {
            'FIELD': 'VALUE',
            'INPUT': outputs['PixelsDeRasterEnPolygones']['OUTPUT'],
            'OPERATOR': 0,  # =
            'VALUE': '0',
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['ExtraireParAttribut'] = processing.run('native:extractbyattribute', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(5)
        if feedback.isCanceled():
            return {}

        # Regrouper tous les polygones en un multi-polygones composé de polygones formés des entités qui se touchent
        alg_params = {
            'FIELD': [''],
            'INPUT': outputs['ExtraireParAttribut']['OUTPUT'],
            'SEPARATE_DISJOINT': False,
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['Regrouper'] = processing.run('native:dissolve', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(6)
        if feedback.isCanceled():
            return {}

        # Sépare le multipolygone en polygones distincts
        alg_params = {
            'INPUT': outputs['Regrouper']['OUTPUT'],
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['DeMorceauxMultiplesMorceauxUniques'] = processing.run('native:multiparttosingleparts', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(7)
        if feedback.isCanceled():
            return {}

        # Calcule l'aire des entités
        if  'TEMPORARY_OUTPUT' in str(parameters['Polygones']) :
            poly_path = temp_folder + '\\polygones.shp'
        else:
            poly_path = parameters['Polygones']

        alg_params = {
            'FIELD_LENGTH': 10,
            'FIELD_NAME': 'aire',
            'FIELD_PRECISION': 3,
            'FIELD_TYPE': 0,  # Décimal (double)
            'FORMULA': 'area($geometry)',
            'INPUT': outputs['DeMorceauxMultiplesMorceauxUniques']['OUTPUT'],
            'OUTPUT': poly_path
        }
        outputs['CalculatriceDeChamp'] = processing.run('native:fieldcalculator', alg_params, context=context, feedback=feedback, is_child_algorithm=True)
        results['Polygones'] = outputs['CalculatriceDeChamp']['OUTPUT']

        feedback.setCurrentStep(8)
        if feedback.isCanceled():
            return {}

        # Extraire les entités dont l'aire est supérieure au seuil fixé en entré ('surface1')
        alg_params = {
            'EXPRESSION': '"aire">'+str(parameters['surface1']),
            'INPUT': outputs['CalculatriceDeChamp']['OUTPUT'],
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['ExtraireParExpression'] = processing.run('native:extractbyexpression', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(9)
        if feedback.isCanceled():
            return {}

        # Réalise une érosion des polygones selon le seuil fixé en entrée ('ouverture') (étape 1/2 de l'ouverture)
        alg_params = {
            'DISSOLVE': False,
            'DISTANCE': -parameters['ouverture'],
            'END_CAP_STYLE': 0,  # Rond
            'INPUT': outputs['ExtraireParExpression']['OUTPUT'],
            'JOIN_STYLE': 0,  # Rond
            'MITER_LIMIT': 2,
            'SEGMENTS': 5,
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['Tampon'] = processing.run('native:buffer', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(10)
        if feedback.isCanceled():
            return {}

        # Réalise une dilatation des polygones selon le seuil fixé en entrée ('ouverture') (étape 2/2 de l'ouverture)
        alg_params = {
            'DISSOLVE': False,
            'DISTANCE': parameters['ouverture'],
            'END_CAP_STYLE': 0,  # Rond
            'INPUT': outputs['Tampon']['OUTPUT'],
            'JOIN_STYLE': 0,  # Rond
            'MITER_LIMIT': 2,
            'SEGMENTS': 5,
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['Tampon'] = processing.run('native:buffer', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(11)
        if feedback.isCanceled():
            return {}

        # Découpe les multi-polygones créés par l'ouverture en polygones distincts
        alg_params = {
            'INPUT': outputs['Tampon']['OUTPUT'],
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['DeMorceauxMultiplesMorceauxUniques'] = processing.run('native:multiparttosingleparts', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(12)
        if feedback.isCanceled():
            return {}

        # Calcule l'aire des entités
        if  'TEMPORARY_OUTPUT' in str(parameters['Ouverture']) :
            ouv_path = temp_folder + '\\ouverture.shp'
        else:
            ouv_path = parameters['Ouverture']

        alg_params = {
            'FIELD_LENGTH': 10,
            'FIELD_NAME': 'aire',
            'FIELD_PRECISION': 3,
            'FIELD_TYPE': 0,  # Décimal (double)
            'FORMULA': 'area($geometry)',
            'INPUT': outputs['DeMorceauxMultiplesMorceauxUniques']['OUTPUT'],
            'OUTPUT': ouv_path
        }
        outputs['CalculatriceDeChamp'] = processing.run('native:fieldcalculator', alg_params, context=context, feedback=feedback, is_child_algorithm=True)
        results['Ouverture'] = outputs['CalculatriceDeChamp']['OUTPUT']

        feedback.setCurrentStep(13)
        if feedback.isCanceled():
            return {}

        # Extrait les entités dont l'aire est supérieure au seuil fixé en entrée ('surface2')
        alg_params = {
            'EXPRESSION': '"aire">'+str(parameters['surface2']),
            'INPUT': outputs['CalculatriceDeChamp']['OUTPUT'],
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['ExtraireParExpression'] = processing.run('native:extractbyexpression', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(14)
        if feedback.isCanceled():
            return {}

        # Réalise une dilatation des polygones selon le seuil fixé en entrée ('fermeture') (étape 2/2 de l'ouverture)
        alg_params = {
            'DISSOLVE': False,
            'DISTANCE': parameters['fermeture'],
            'END_CAP_STYLE': 0,  # Rond
            'INPUT': outputs['ExtraireParExpression']['OUTPUT'],
            'JOIN_STYLE': 0,  # Rond
            'MITER_LIMIT': 2,
            'SEGMENTS': 5,
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['Tampon'] = processing.run('native:buffer', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(15)
        if feedback.isCanceled():
            return {}

        # Réalise une érosion des polygones selon le seuil fixé en entrée ('fermeture') (étape 1/2 de l'ouverture)
        if  'TEMPORARY_OUTPUT' in str(parameters['Fermeture']) :
            fer_path = temp_folder + '\\fermeture.shp'
        else:
            fer_path = parameters['Fermeture']
        alg_params = {
            'DISSOLVE': False,
            'DISTANCE': -parameters['fermeture'],
            'END_CAP_STYLE': 0,  # Rond
            'INPUT': outputs['Tampon']['OUTPUT'],
            'JOIN_STYLE': 0,  # Rond
            'MITER_LIMIT': 2,
            'SEGMENTS': 5,
            'OUTPUT': fer_path
        }
        outputs['Tampon'] = processing.run('native:buffer', alg_params, context=context, feedback=feedback, is_child_algorithm=True)
        results['Fermeture'] = outputs['Tampon']['OUTPUT']

        feedback.setCurrentStep(16)
        if feedback.isCanceled():
            return {}

        # Calcule la convexité des entités
        alg_params = {
            'FIELD_LENGTH': 10,
            'FIELD_NAME': 'convexite',
            'FIELD_PRECISION': 3,
            'FIELD_TYPE': 0,  # Décimal (double)
            'FORMULA': '"aire" / area(convex_hull($geometry))',
            'INPUT': outputs['Tampon']['OUTPUT'],
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['CalculatriceDeChamp'] = processing.run('native:fieldcalculator', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(17)
        if feedback.isCanceled():
            return {}

        # Calcule l'emprise orientée minimale (OMBB)
        alg_params = {
            'INPUT': outputs['CalculatriceDeChamp']['OUTPUT'],
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['EmpriseOrienteMinimaleOmbb'] = processing.run('native:orientedminimumboundingbox', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(18)
        if feedback.isCanceled():
            return {}

        # Calcule l'élongation des entités        
        if  'TEMPORARY_OUTPUT' in str(parameters['Ombb']) :
            ombb_path = temp_folder + '\\ombb.shp'
        else:
            ombb_path = parameters['Ombb']

        alg_params = {
            'FIELD_LENGTH': 10,
            'FIELD_NAME': 'elongation',
            'FIELD_PRECISION': 3,
            'FIELD_TYPE': 0,  # Décimal (double)
            'FORMULA': '"height"/"width"',
            'INPUT': outputs['EmpriseOrienteMinimaleOmbb']['OUTPUT'],
            'OUTPUT': ombb_path
        }
        outputs['CalculatriceDeChamp'] = processing.run('native:fieldcalculator', alg_params, context=context, feedback=feedback, is_child_algorithm=True)
        results['Ombb'] = outputs['CalculatriceDeChamp']['OUTPUT']

        feedback.setCurrentStep(19)
        if feedback.isCanceled():
            return {}
        
        # Extrait les entités dont l'élongation est supérieure au seuil fixé en entrée ('elongation') et dont la convexité est supérieure au seuil fixé en entrée ('convexite')
        if  'TEMPORARY_OUTPUT' in str(parameters['Resultat']) :
            result_path = temp_folder + '\\resultats.shp'
        else:
            result_path = parameters['Resultat']
        
        alg_params = {
            'EXPRESSION': '"elongation">'+str(parameters['elongation'])+' AND "convexite">'+str(parameters['convexite']),
            'INPUT': outputs['CalculatriceDeChamp']['OUTPUT'],
            'FAIL_OUTPUT': QgsProcessing.TEMPORARY_OUTPUT,
            'OUTPUT': result_path
        }
        outputs['ExtraireParExpression'] = processing.run('native:extractbyexpression', alg_params, context=context, feedback=feedback, is_child_algorithm=True)
        results['Resultat'] = outputs['ExtraireParExpression']['OUTPUT']

        feedback.setCurrentStep(20)
        if feedback.isCanceled():
            return {}
        
        # Extraire les entités qui intersecte un point de vérité terrain
        if 'None' not in str(parameters['verite_terrain']) :
            if  'TEMPORARY_OUTPUT' in str(parameters['Bien_detectee']) :
                bd_path = temp_folder + '\\bien_detectee.shp'
            else:
                bd_path = parameters['Bien_detectee']
    
            alg_params = {
                'INPUT': outputs['ExtraireParExpression']['OUTPUT'],
                'INTERSECT': outputs['DcouperDesVecteursSelonUneEmprise']['OUTPUT'],
                'PREDICATE': [0],  # intersecte
                'OUTPUT': bd_path
            }
            outputs['ExtraireParLocalisation'] = processing.run('native:extractbylocation', alg_params, context=context, feedback=feedback, is_child_algorithm=True)
            results['Bien_detectee'] = outputs['ExtraireParLocalisation']['OUTPUT']
            
            #Exporte dans une couche Shapefile les résultats bien détectés
            bien_detectee = QgsVectorLayer(outputs['ExtraireParLocalisation']['OUTPUT'],'Bien_detectee','ogr')
            
            #Exporte dans une couche Shapefile tous les résultats détectés
            resultats = QgsVectorLayer(outputs['ExtraireParExpression']['OUTPUT'],'Resultat','ogr')
            
            #Extrait dans une couche Shapefile les points de vérité terrain qui intersecte la dalle étudiée
            verite_terrain = QgsVectorLayer(outputs['DcouperDesVecteursSelonUneEmprise']['OUTPUT'],'Verite_dalle','ogr')
            
            #Calcule la précision, le rappel et le fscore de la procédure
            precision = bien_detectee.featureCount()/resultats.featureCount()
            rappel = bien_detectee.featureCount()/verite_terrain.featureCount()
            fscore = 2*precision*rappel/(precision+rappel)
            
            results['precision'] = precision
            results['rappel'] = rappel
            results['fscore'] = fscore
        
        return results

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Detection des erreurs LiDAR'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return ''

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return DetectionErreursLidarAlgorithm()

    def shortHelpString(self):
        return self.tr("Ce plugin vous donnera une couche de polygones susceptibles d'être des erreurs de déclassement.\n Si vous avez une couche de vérité terrain (ponctuelle), il peut également vous fournir la précision, le rappel et le fscore de la procédure.\nLes polygones seront générés en fonction des seuils de surface et des distances d'ouverture et fermeture et seront sélectionés selon leurs convexité et élongation. ")